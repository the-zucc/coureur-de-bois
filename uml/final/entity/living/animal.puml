@startuml animal
class Légende{
        - private
        # protected
        + public
        {abstract} abstract
        {static} static
    }
package entity{
    abstract class Entity #888888{
        + Entity(Point3D):Entity
        ==
        - id:String
        + getId():String
        --
        # position:Point3D
        + getPosition():Point3D
        --
        # collisionBox:CollisionBox
        + getCollisionBox():CollisionBox
        --
        # component:Component
        # {abstract} buildComponent():Component
        + getComponent():Component
        --
        # update(double):void
        # fall():void
        # correctCollisions():void
        --
        onMouseEntered(MouseEvent):void
        onMouseExit(MouseEvent):void
    }
    package entity.attachable{
        interface Attachable{
            onAttach(AttachableReceiver):void
            onDetach(AttachableReceiver):void
            onUpdate(AttachableReceiver):void
        }
        interface LevelRestrictedAttachable{    
            getMinimumLevel():int
            canHumanReceive(Human):boolean
        }
        LevelRestrictedAttachable --|> Attachable
        interface AttachableReceiver{
            onReceive(Attachable):void
            updateAttachables():void
        }
        AttachableReceiver "1" *-- "n" Attachable
    }
    package entity.living{
        abstract class LivingEntity{
            # hp:double
            # xpReward:double
            ==
            # move():void
            + getAttacked(double, LivingEntity):void
            # onDeath():void
            # jump():void
            ==
            # setUp(boolean):void
            # setDown(boolean):void
            # setLeft(boolean):void
            # setRight(boolean):void
        }
        LivingEntity --|> Entity
        package entity.living.animal{
            enum State{
                WALKING
                WATCHING_AROUND
                --
                WAITING
                SMELLING_GROUND
                EATING_EATABLESTATIC
                RUNNING_FROM_PREDATOR
                --
                RUNNING_AFTER_PREY
                WALKING_TO_PREY
                SEARCHING_FOR_PREY
                ATTACKING_PREY
                ==
                getRandomState_predator():State
                getRandomState_prey():State
            }
            abstract class Animal{
                # nanosecondsWhenStateWasChosen:long
                # state:State
                # running:boolean
                # walking:boolean
                # {abstract}shouldChangeState():boolean
                # {abstract}chooseNextState():State
                # updateState():void
                # startWalkingTo(Point3D):void
                # startRunningTo(Point3D):void
                'the following method should be used to check if the prey is moving,
                'in the event that a predator would be after it. 
                + getState():State
            }
            Animal --|> LivingEntity
            Animal <-- State
            'INTERFACES HERE
            package entity.living.animal.foodchain{
                interface FoodChainMember{
                    'shouldScanForFood():boolean
                    'scanForFoodAndStartEatingIfNecessary():void
                }
                interface Prey{
                    # scanForIncomingPredators():Predator
                    # startRunningFromPredator(Predator):void
                }
                Prey --|> FoodChainMember
                interface Predator{
                    + getLevelInFoodChain():int
                    # targetPrey(Prey):void
                    # startRunningAfterPrey(Prey):void
                    # scanForPrey():Prey
                    + getTargetedPrey():Prey
                }
                Predator --|> FoodChainMember
            }
            'HEBIVORE AND CARNIVORE
            abstract class Herbivore{
                + targetEatableStatic(EatableStatic):void
                + eat(EatableStatic):void
            }
            Herbivore --|> Animal
            Herbivore --|> Prey
            abstract class Carnivore{

            }
            Carnivore --|> Animal
            Carnivore --|> Predator

            'HERBIVORES HERE
            class Moose
            Moose --|> Herbivore
            class Rabbit{
                - hop(double, double, double):void
            }
            'note top:le joueur pourra\navoir un lapin\ncomme animal\nde compagnie
            Rabbit --|> Herbivore
            Rabbit --|> Attachable
            'CARNIVORES HERE
            class Fox
            Fox --|> Carnivore
            Fox --|> Prey
            class Wolf
            Wolf --|> Carnivore
        }
        package entity.living.human{
        }
    }
    package entity.static{
        interface EatableStatic{
            + onGetEaten(Herbivore):void
        }
        Herbivore <-- EatableStatic
    }
}
@enduml