@startuml
skinparam class {
    BackgroundColor #ffffff
    ArrowColor #000000
    BorderColor #000000
}
skinparam stereotypeCBackgroundColor<<Singleton>> #FF7700




'entités de jeu
package entity #888888{
    abstract class Entity{
        # id:String
        # position:Point3D
        # collisionBox:CollisionBox
        + getId():String
        + getPosition():Point3D
        + {abstract} buildComponent():Component
        # fall():void
        # correctCollisions():void
    }
    
    package entity.item #337777{
        abstract class Item{
            owner:Human
        }
        Item <|-- Entity
        

        abstract class Wearable{

        }
        Wearable <|-- Item
        abstract class Weapon{
            # {static}name:String
            setOwner(Human):void
            attack():void
        }
        Weapon <|-- Wearable
        abstract class MeleeWeapon{
            swing()
        }
        MeleeWeapon <|--Weapon
        abstract class RangedWeapon{
            {abstract}shoot(double, double, double, double):void
        }
        RangedWeapon <|-- Weapon
        abstract class Consumable{
            getConsumed(LivingEntity consumingEntity)
        }
        Consumable <|-- Item
        abstract class Fruit{
            size:FruitSize
            Fruit():Fruit
        }
        Fruit <|-- Consumable
        class Apple{

        }
        Apple <|-- Fruit
        class Berry{

        }
        Berry <|-- Fruit
        class Blueberry{

        }
        Blueberry <|-- Berry
        class Blackberry{
        }
        Blackberry <|-- Berry
        class TallEatableGrass{

        }
        TallEatableGrass <|-- Fruit
        enum FruitSize{
            VERY_SMALL
            SMALL
            MEDIUM
            LARGE
            VERY_LARGE
            HUGE
            getRandomSize(boolean):FruitSize
            'boolean is: gaussian distributed probabilities?
            
        }
    }
    'entité générique
    
    
    
    abstract class LivingEntity{
        # hp:double
        # xpReward:double
        # move():void
        # date():void
        # dealdamage(double):void
        # die():void
        # jump():void
    }
    LivingEntity <|-- Entity
    
    'les humains du jeu
    abstract class Human{
        # inventory:ArrayList<Item>
    }
    Human *-- Item: "1..*"
    Human <|-- LivingEntity

    'le joueur incarne un humain
    class Player{
        + setUp(boolean):void
        + setDown(boolean):void
        + setLeft(boolean):void
        + setRight(boolean):void
        + attack(LivingEntity):void
    }
    Player <|-- Human
    
    abstract class Npc{
        
    }
    Npc <|-- Human

    'les autochtones dans le jeu
    class Aboriginal{
        + trade(Item):Item
        # group:HumanGroup
        
    }
    Aboriginal <|-- Npc

    abstract class Animal{
    }
    Animal <|-- LivingEntity
    class Deer{

    }
    Deer <|-- Herbivore
    class Moose{

    }
    Moose <|-- Herbivore
    class Beaver{
        givePelt():Item
    }
    Beaver <|-- Herbivore
    class Carnivore{
        -prey:LivingEntity
        +getPrey():LivingEntity
    }
    Carnivore <|--Animal
    class Fox{

    }
    Fox <|-- Carnivore
    class Wolf{

    }
    Wolf <|-- Carnivore
    class Herbivore{

    }
    Herbivore <|-- Animal
    class Bear{

    }
    Bear <|-- Carnivore
    class Rabbit{

    }
    Rabbit <|-- Herbivore
    abstract class Plant{
        
    }
    Plant <|-- Entity
    Plant "1" *-- "n" Fruit
    abstract class Tree{

    }
    Tree <|-- Plant
    class Bouleau{

    }
    Bouleau <|-- Tree
    class Sapin{

    }
    Sapin <|-- Tree
    class AppleTree{
        # dropApple():void
        + getHit(double damage, MeeleeWeapon mw):void
        + 
    }
    AppleTree <|-- Tree
    package humangroup{
        class HumanGroup{
            members:ArrayList<Aboriginal>
            HumanGroup(ArrayList<Aboriginal>):HumanGroup
            'for with members
            HumanGroup(ArrayList<Aboriginal>, double):HumanGroup
            'for with members and area radius
            getMembers():ArrayList<Aboriginal>
            getPosition():Point3D
            getRadius():double
        }
    }
    package entity.collision #888888{
        'grille de collisions
        class CollisionGrid<<Singleton>>{
            collisionBoxes:ArrayList<CollisionBox>
        }
        CollisionGrid "1" *-- "n"CollisionBox
        
        'boite de collision générique
        abstract class CollisionBox{

            {abstract}collidesSphericalBox():boolean
            '{abstract}collidesCubeBox():boolean
            {abstract}collidesCapsuleBox():boolean
            
            {abstract}getCorrectionSphericalBox():Point3D
            '{abstract}getCorrectionCubeBox():Point3D
            {abstract}getCorrectionCapsuleBox():Point3D

        }
        CollisionBox <-- Entity 

        'sphère
        class SphericalCollisionBox{

        }
        SphericalCollisionBox <|-- CollisionBox
        'capsule
        class CapsuleCollisionBox{

        }
        CollisionBox --|> CapsuleCollisionBox
        'CubeCollisionBox <|-- CollisionBox
    }
'CollisionBox --> Entity
}

package visual{
    class Component
}

package javafx{
    package javafx.scene{
        class Group
    }
    Component <|-- Group
    package javafx.geometry{
        class Point3D
        Point3D <-- Entity
    }
}
package util{
    interface dateable{
        + date(double):void
    }
    class IdMaker{
        - {static} id:int
        + {static} nextId():String
    }
}
package visual #888888{
    abstract class Component{
        # id:String
        + getId():String
        # position:Point3D
    }
    'Entity --> Component
    
    class PlayerComponent{
        + PlayerComponent(String)
    }
    PlayerComponent --|> Component
    class MooseComponent{

    }
    MooseComponent <|-- Component
}
@enduml
@startuml
'javafx, la base de l'engin graphique du programme
package javafx{
    
    package javafx.stage{
        class Stage
        note bottom:fenêtre\nd'application
    }

    package javafx.scene #ffffff{
        class Scene
        note top:graphe de scène qui\npossède un noeud\nracine qui possède\ndes enfants
        Stage --> Scene
        
        
        abstract class Node{

        }
        'note:classe\ngénérique\npour\nles\nnoeuds
        Parent *-- Node:"1..*"

        class SubScene
        note bottom:graphe de scène\nqui agit comme\nun noeud 2D au sein\nd'une scène, mais qui\nest aussi une scène\nen soi.
        SubScene <|-- Node
        SubScene <|-- Scene

        abstract class Parent
        note top:indique\nque le\nnoeud\na des\nenfants 
        Parent <|--Node
        Scene --> Parent
        
        class Gro
        note top:utilisé dans\nle contexte\nactuel, sert\nsimplement\nà déclarer\nles positions\navec des\ncoordonnées\nX,Y,Z 
        Gro <|-- Parent
    }
    
    package javafx.geometry{
        class Point3D
    }
    package application{
        class Application{
        
        }
        Application "    1..*" *-- Stage: "une application\npeut posséder\nplusieurs fenêtres"
    }
}

'package de l'application
package app #e25846{
    skinparam stereotypeCBackgroundColor<<Singleton>> #FF7700
    class Model<<Singleton>>{
        - {static} Instance:Model
        + getInstance():Model
    }
    class UI<<Singleton>>{
        - {static} Instance:Model
        + getInstance():Model
    }
    UI <|-- Scene
    class GameScene<<Singleton>>{
        - {static} Instance:GameScene
        + getInstance():GameScene
    }
    note bottom:pour permettre de superposer\ndu rendu 3D à du rendu 2D,\nune scène en 2D est nécessaire.\nOn ajoute simplement un noeud\n qui sera une <i>SubScene à la scène\n2D. Elle sera manipulée comme\nun objet 2D, mais aura les fonctionnalités\nd'une scène en 3D\n(donc l'ajout de noeuds sera possible)
    GameScene <|-- SubScene
    
    UI --> GameScene
    class Controller{
        applicationWindow:javafx.stage.Stage
    }
    'note :la classe <i>Controller\ninitialise les Singletons\ndans le bon ordre
    Controller --> UI
    Controller --> GameScene: "initialise"
    Controller --> Model
    Controller --|> Application
}
@enduml