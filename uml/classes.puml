@startuml
skinparam class {
    BackgroundColor #ffffff
    ArrowColor #000000
    BorderColor #000000
}
skinparam stereotypeCBackgroundColor<<Singleton>> #FF7700
'javafx, la base de l'engin graphique du programme
package javafx{
    
    package javafx.stage{
        class Stage
        note bottom:fenêtre\nd'application
    }

    package javafx.scene #ffffff{
        class Scene
        note top:graphe de scène qui\npossède un noeud\nracine qui possède\ndes enfants
        Stage -left-> Scene
        
        
        abstract class Node
        note right:classe\ngénérique\npour\nles\nnoeuds
        Parent *-down- Node:"1..*"

        class SubScene
        note bottom:graphe de scène\nqui agit comme\nun noeud 2D au sein\nd'une scène, mais qui\nest aussi une scène\nen soi.
        SubScene <|-left- Node
        SubScene <|-up- Scene

        abstract class Parent
        note top:indique\nque le\nnoeud\na des\nenfants 
        Parent <|-down-Node
        Scene -right-> Parent
        
        abstract class Group
        note top:utilisé dans\nle contexte\nactuel, sert\nsimplement\nà déclarer\nles positions\navec des\ncoordonnées\nX,Y,Z 
        Group <|-left- Parent
    }
    
    package javafx.geometry{
        class Point3D
    }
    package application{
        class Application{
        
        }
        Application *-- Stage : "1..*"
    }
}

'package de l'application
package app #e25846{
    class Model<<Singleton>>{
        - {static} Instance:Model
        + getInstance():Model
    }
    class UI<<Singleton>>{
        - {static} Instance:Model
        + getInstance():Model
    }
    UI <|-- Scene
    class GameScene<<Singleton>>{
        - {static} Instance:GameScene
        + getInstance():GameScene
    }
    'note bottom:pour permettre de superposer\ndu rendu 3D à du rendu 2D,\nune scène en 2D est nécessaire.\nOn ajoute simplement un noeud\n qui sera une <i>SubScene à la scène\n2D. Elle sera manipulée comme\nun objet 2D, mais aura les fonctionnalités\nd'une scène en 3D\n(donc l'ajout de noeuds sera possible)
    GameScene <|-- SubScene
    
    UI -left-> GameScene
    class Controller{
        applicationWindow:javafx.stage.Stage
    }
    'note left:la classe <i>Controller\ninitialise les Singletons\ndans le bon ordre
    Controller --> UI
    Controller --> GameScene: "initialise"
    Controller -left-> Model
    Controller -left-|> Application
}

package util{
    interface Updateable{
        + update(double):void
    }
    class IdMaker{
        - {static} id:int
        + {static} nextId():String
    }
}

'entités de jeu
package entity #888888{
    'entité générique
    abstract class Entity{
        # id:String
        # position:Point3D
        # collisionBox:CollisionBox
        + getId():String
        + getPosition():Point3D
        + {abstract} buildComponent():Component
        # fall():void
    }
    Point3D <-down- Entity
    
    
    abstract class LivingEntity{
        # hp:double
        # xpReward:double
        # move():void
        # update():void
        # dealdamage(double):void
        - die():void
        - jump():void
    }
    LivingEntity <|-down- Entity
    
    'les humains du jeu
    abstract class Human{
        - inventory:ArrayList<Item>
    }
    Human <|-down- LivingEntity

    'le joueur incarne un humain
    class Player{
        + setUp(boolean):void
        + setDown(boolean):void
        + setLeft(boolean):void
        + setRight(boolean):void
        + attack(LivingEntity):void
    }
    Player <|-left- Human
    
    abstract class Npc{

    }
    Npc <|-down- Human

    'les autochtones dans le jeu
    class NativePerson{
        + trade(Item):Item
    }
    NativePerson <|-left- Npc

    'Mobs comme des animaux, des créatures, etc
    abstract class Animal{
        - {abstract} targetFood():void
    }
    Animal <|-left- LivingEntity
    class Deer{

    }
    Deer <|-- VegetableEater
    class Moose{

    }
    Moose <|-left- VegetableEater
    class MeatEater{

    }
    MeatEater <|-up-Animal
    class Fox{

    }
    Fox <|-left- MeatEater
    class Wolf{

    }
    Wolf <|-left- MeatEater
    class VegetableEater{

    }
    VegetableEater <|-left- Animal
    class Bear{

    }
    Bear <|-left- MeatEater
    class Rabbit{

    }
    Rabbit <|-- VegetableEater
    abstract class Tree{

    }
    Tree <|-right- Entity
    class Bouleau{

    }
    Bouleau <|-- Tree
    class Sapin{

    }
    Sapin <|-- Tree
}

package collision #888888{
    'grille de collisions
    class CollisionGrid<<Singleton>>{
        collisionBoxes:ArrayList<CollisionBox>
    }
    CollisionGrid "1" *-up- "n"CollisionBox
    
    'boite de collision générique
    abstract class CollisionBox{

        {abstract}collidesSphericalBox():boolean
        {abstract}collidesCubeBox():boolean
        {abstract}collidesCapsuleBox():boolean
        
        {abstract}getCorrectionSphericalBox():Point3D
        {abstract}getCorrectionCubeBox():Point3D
        {abstract}getCorrectionCapsuleBox():Point3D

    }
    Entity -right-> CollisionBox

    'sphère
    class SphericalCollisionBox{

    }
    SphericalCollisionBox <|-down- CollisionBox
    'capsule
    class CapsuleCollisionBox{

    }
    CollisionBox -right-|> CapsuleCollisionBox
    'CubeCollisionBox <|-left- CollisionBox
}
'CollisionBox -right-> Entity

package visual #888888{
    abstract class Component{
        - id:String
        + getId():String
        - position:Point3D
    }
    'Entity -right-> Component
    Component <|-left- Group
    class PlayerComponent{
        + PlayerComponent(String)
    }
    PlayerComponent -left-|> Component
    class MooseComponent{

    }
    MooseComponent <|-up- Component

    
}


package item #337777{
    abstract class Item{
    }
    
    Human *-- Item: "1..*"

    abstract class Wearable{

    }
    Wearable <|-right- Item
    abstract class Weapon{
        
    }
    Weapon <|-right- Wearable
    abstract class MeleeWeapon{

    }
    MeleeWeapon <|-down-Weapon
    abstract class RangedWeapon{

    }
    RangedWeapon <|-up- Weapon
    abstract class Consumable{

    }
    Consumable <|-up- Item
    
    
}



@enduml